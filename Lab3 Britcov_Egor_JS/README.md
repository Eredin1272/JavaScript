# Лабораторная работа №3. Расширенные возможности объектов в JavaScript

## Цель занятия

Ознакомиться с концепцией классов и объектов в JavaScript, а также научиться:
- создавать собственные классы;
- применять конструкторы и методы;
- реализовывать наследование между классами.

## Условие

Разработать консольное приложение, имитирующее работу инвентарной системы, с возможностью:
- добавления предметов;
- редактирования их свойств;
- управления объектами с помощью методов классов.

## Шаг 1. Создание класса `Item`

Создал базовый класс `Item`, представляющий предмет инвентаря.

### Поля класса:
- `name` — название предмета;
- `weight` — вес предмета (число ≥ 0);
- `rarity` — редкость предмета:  
  `rare`, `epic`, `legendary`, `mithycal`.

### Методы:
- `getInfo()` — возвращает строку с описанием предмета;
- `setWeight(newWeight)` — изменяет вес предмета.
---
### Пример использования:
```javascript
//Выводим информацию о предмете
    const sword = new Item("Steel Sword", 3.5, "rare");
    console.log(sword.getInfo()); // Предмет: Steel Sword, Вес: 3.5, Редкость: Rare
```

```javascript
// Изменяем вес
    sword.setWeight(4.0);
    console.log(`Текущий вес меча: ${sword.weight.toFixed(1)}`);
    console.log(sword.getInfo()); // Предмет: Steel Sword, Вес: 4.0 , Редкость: Rare
```
---
## Шаг 2. Создание класса `Weapon`

Класс `Weapon` расширяет `Item` и добавляет функциональность оружия.

### Дополнительные поля:
- `damage` — урон оружия (целое число);
- `durability` — прочность (от 0 до 100).

### Методы:
- `use()` — уменьшает `durability` на 10, но не ниже 0;
- `repair()` — восстанавливает `durability` до 100;
- `getInfo()` — переопределён для отображения урона и прочности.

### Пример использования:
```javascript
const bow = new Weapon("Longbow", 2.0, "uncommon", 15, 100);
console.log(bow.getInfo());       // Предмет: Longbow, Вес: 2.0, Редкость: Uncommon, Урон: 15, Прочность: 100%
bow.use();                        // Прочность уменьшается на 10
console.log(bow.durability);      // 90
bow.repair();                     // Прочность восстанавливается до 100
```

---
## Шаг 3. Тестирование:
Были созданы и пропущены через тесты и проверки следующие объекты:
### Объекты класса `Item`:
- `Silver Sword` — с редкостью `rare`, вес изменён с 3.5 до 9, редкость с `rare` до `epic`.
```js
const sword = new Item("Silver Sword", 3.5, "Rare");
  console.log(sword.getInfo());
  sword.setWeight(9);
  sword.setRarity("legendary");
  //| Предмет: Silver Sword | Вес: 3.5kg | Редкость: rare |
//После изменений: | Предмет: Silver Sword | Вес: 9kg | Редкость: legendary |
```
- `Golden Bow` —  с редкостью `secret` и неправильно заданным весом.
```js
const bow = new Item("Golden Bow", -1, "secret");
  console.log(bow.getInfo());
  //Ошибка при создании предмета: Вес должен быть положительным числом.
  //Ошибка при создании предмета: Редкость должна быть одной из: rare, epic, legendary, mythical.
```

### Объекты класса `Weapon`:
- `Spiked Mace` — протестировано с многократным использованием и починкой.

 Создание предмета:
```js
 const mace = new Weapon("Spiked Mace", 5.0, "Legendary", 30, 70);
  console.log(mace.getInfo());
  //| Предмет: Spiked Mace | Вес: 5kg | Редкость: legendary | Урон: 30 | Прочность: 70% |
```
 Изменение урона и редкости:
```js
mace.setDamage(50);
  mace.setRarity("Epic");
  console.log(`После изменений: ${mace.getInfo()}`);
  //После изменений: | Предмет: Spiked Mace | Вес: 5kg | Редкость: epic | Урон: 50 | Прочность: 70% |
```
 Многократное использование предмета:
```js
 for (let i = 0; i < 8; i++) {
    mace.use();
  }
  console.log(`Durability after using Spiked Mace: ${mace.durability}`);
  //Был использован Spiked Mace. Прочность уменьшилась до 60%.
  //...
  //Был использован Spiked Mace. Прочность уменьшилась до 0%.
  //Spiked Mace сломан!
  //Spiked Mace сломан и не может быть использован.
```
 Чиним `Spiked Mace` 2 раза:
```js
mace.repair();
  mace.repair();
  console.log(`Durability after repairing: ${mace.durability}`);
  //Чиним Spiked Mace...
  //Spiked Mace отремонтирован. Прочность востоновленна до 100%.
  //Spiked Mace предмет не нуждается в ремонте.
  //Durability after repairing: 100
```
---
- `Poseidon Axe` - выводим информацию о предмете:
```js
const axe = new Weapon("Poseidon Axe", 8.7, "Mythical", 50, 90);
  console.log(axe.getInfo());
  //| Предмет: Poseidon Axe | Вес: 8.7kg | Редкость: mythical | Урон: 50 | Прочность: 90% |
```
 Также производим использование и починку:
```js
axe.use();
  console.log(`Durability after using Poseidon Axe: ${axe.durability}`);
  axe.repair();
  console.log(`Durability after repairing: ${axe.durability}`);
  //Был использован Poseidon Axe. Прочность уменьшилась до 80%.
  //Durability after using Poseidon Axe: 80
  //Чиним Poseidon Axe...
  //Poseidon Axe отремонтирован. Прочность востоновленна до 100%.
  //Durability after repairing: 100
```
---
## Шаг 4. Переписать с использованием функций-конструкторов и опциональной цепочки.
[Код](Script2.js)
- Пример использования

Создание предмета:
```js
const mace = new Weapon("Spiked Mace", 5.0, "Legendary", 30, 70);
    console.log(mace.getInfo());
    //| Предмет: Spiked Mace | Вес: 5kg | Редкость: legendary | Урон: 30 | Прочность: 70% |
```
Использование предмета и починка:
```js
mace.use();
    console.log(mace.getInfo());
    //| Предмет: Spiked Mace | Вес: 5kg | Редкость: legendary | Урон: 30 | Прочность: 60% |
    // Чиним оружие
    mace.repair();
    console.log(mace.getInfo());
    //| Предмет: Spiked Mace | Вес: 5kg | Редкость: legendary | Урон: 30 | Прочность: 100% |
```
Опциональная цепочка:
```js
// 4) Опциональная цепочка
  console.log(mace?.damage);   // 50
  console.log(sword?.durability);  // undefined, без ошибки
```
Во втором случае выводит в консоль `undefined` потому что свойство `durability` не было определено ранее для класса `Item`.
---
## Контрольные вопросы

1. **Какую роль играет `this` в методах класса?**  
Внутри метода класса ключевое слово `this` ссылается на конкретный экземпляр объекта, созданный на основе данного класса. Это позволяет обращаться к его свойствам и вызывать другие методы. К примеру, если объект `potion` создан через класс `Item`, то при вызове `potion.getInfo()` внутри метода `getInfo` `this` будет указывать именно на `potion`.

2. **Что делает модификатор доступа `#` в JavaScript?**  
Символ `#` используется для обозначения приватных свойств и методов внутри классов. Такие элементы недоступны за пределами класса и могут быть использованы только внутри него, обеспечивая скрытие данных и защиту от внешнего вмешательства. Например, при объявлении `#secretCode = 12345` обращение к `object.#secretCode` вне класса вызовет ошибку.

3. **Чем отличаются классы от функций-конструкторов?**  
Классы и функции-конструкторы оба применяются для создания объектов, но классы предлагают более современный и лаконичный синтаксис, введённый в ES6. Классы упрощают наследование с помощью `extends` и `super()`, а также поддерживают приватные поля. Функции-конструкторы — это более старый способ, где объекты создаются через `new`, а наследование реализуется с помощью `Object.create()` и `call`. По сути, классы являются синтаксическим улучшением (сахаром) над конструкторами, делая код более читаемым и удобным для поддержки.
---
## Вывод

В процессе выполнения лабораторной работы были:

- разработаны классы с применением наследования;
- изучены базовые принципы объектно-ориентированного программирования в JavaScript;
- освоена работа с методами и валидацией данных;
- проверена работоспособность приложения через консольные тесты.
